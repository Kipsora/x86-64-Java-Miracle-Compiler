; Code generated by Kipsora

default rel

extern puts
extern malloc
extern scanf

global main

section .bss
int$buf:	resw 1

section .data
global$str17:	db 2, 0, 0, 0, 10, 0
int$fmt:	db 25H, 64H, 00H

section .text
__init:
____init.entry:
	push rbp
	mov rbp, rsp
	jmp ____init.exit
____init.exit:
	leave
	ret

main:
__main.entry:
	push rbp
	mov rbp, rsp
	sub rsp, 112
	call __init
	mov dword [rbp-4], 10000
	mov dword [rbp-8], 0
	mov dword [rbp-12], 2800
	mov dword [rbp-16], 0
	mov dword [rbp-20], 0
	mov edi, 11204
	call malloc
	mov dword [rbp-24], eax
	mov ecx, dword [rbp-24]
	mov dword [rbp-28], 0
	mov dword [rbp-32], ecx
	jmp iter_cond_0
iter_cond_0:
	mov ecx, dword [rbp-8]
	mov r8d, dword [rbp-12]
	sub ecx, r8d
	cmp ecx, 0
	setne byte [rbp-33]
	mov dword [rbp-37], ecx
	mov dword [rbp-12], r8d
	cmp byte [rbp-33], 0
	jnz iter_body_1
	jmp iter_exit_2
iter_exit_2:
	jmp iter_cond_3
iter_cond_3:
	jmp iter_body_4
iter_body_4:
	mov dword [rbp-16], 0
	mov ecx, dword [rbp-12]
	imul ecx, 2
	mov dword [rbp-28], ecx
	mov dword [rbp-41], ecx
	cmp dword [rbp-28], 0
	je if_pass_6
	jmp if_fail_7
if_fail_7:
	jmp if_both_8
if_both_8:
	mov ecx, dword [rbp-12]
	mov dword [rbp-8], ecx
	jmp iter_cond_9
iter_cond_9:
	jmp iter_body_10
iter_body_10:
	mov ecx, dword [rbp-32]
	mov r8d, dword [rbp-8]
	mov edx, dword [ecx+r8d*4]
	mov r9d, dword [rbp-4]
	imul edx, r9d
	mov eax, dword [rbp-16]
	add eax, edx
	mov dword [rbp-16], eax
	dec dword [rbp-28]
	mov ebx, dword [rbp-16]
	mov dword [rbp-45], edx
	mov dword [rbp-49], eax
	mov eax, ebx
	cdq
	idiv dword [rbp-28]
	mov ebx, edx
	mov dword [ecx+r8d*4], ebx
	mov esi, dword [rbp-28]
	dec dword [rbp-28]
	mov r10d, dword [rbp-16]
	mov dword [rbp-45], edx
	mov dword [rbp-49], eax
	mov eax, r10d
	cdq
	idiv esi
	mov r10d, eax
	mov dword [rbp-16], r10d
	dec r8d
	mov dword [rbp-53], r10d
	mov dword [rbp-32], ecx
	mov dword [rbp-8], r8d
	mov dword [rbp-45], edx
	mov dword [rbp-4], r9d
	mov dword [rbp-49], eax
	mov dword [rbp-57], ebx
	mov dword [rbp-61], esi
	cmp r8d, 0
	je if_pass_12
	jmp if_fail_13
if_pass_12:
	jmp iter_exit_11
iter_exit_11:
	mov ecx, dword [rbp-12]
	sub ecx, 14
	mov dword [rbp-12], ecx
	mov r8d, dword [rbp-16]
	mov eax, r8d
	cdq
	idiv dword [rbp-4]
	mov r8d, eax
	mov edx, dword [rbp-20]
	add edx, r8d
	mov edi, edx
	call @toString
	mov dword [rbp-65], eax
	mov edi, dword [rbp-65]
	call @print
	mov r9d, dword [rbp-16]
	mov dword [rbp-69], edx
	mov eax, r9d
	cdq
	idiv dword [rbp-4]
	mov r9d, edx
	mov dword [rbp-20], r9d
	mov dword [rbp-73], ecx
	mov dword [rbp-77], r8d
	mov dword [rbp-69], edx
	mov dword [rbp-81], r9d
	jmp iter_cond_3
if_fail_13:
	jmp if_both_14
if_both_14:
	mov ecx, dword [rbp-16]
	mov r8d, dword [rbp-8]
	imul ecx, r8d
	mov dword [rbp-16], ecx
	mov dword [rbp-85], ecx
	mov dword [rbp-8], r8d
	jmp iter_cond_9
if_pass_6:
	jmp iter_exit_5
iter_exit_5:
	mov edi, global$str17
	call @print
	mov eax, 0
	jmp __main.exit
__main.exit:
	leave
	ret
iter_body_1:
	mov ecx, dword [rbp-8]
	inc dword [rbp-8]
	mov r8d, dword [rbp-4]
	mov dword [rbp-89], 5
	mov eax, r8d
	cdq
	idiv dword [rbp-89]
	mov r8d, eax
	mov edx, dword [rbp-32]
	mov dword [edx+ecx*4], r8d
	mov dword [rbp-93], ecx
	mov dword [rbp-97], r8d
	mov dword [rbp-32], edx
	jmp iter_cond_0

@println:
	lea edi, [edi+4]
	call puts
	ret
@toString:
    cmp edi, 0
    jge __positive@toString
    neg edi
	mov ebx, edi
	mov edi, 15
	call malloc
	lea edi, [eax+13]
	mov eax, ebx
	mov ebx, 10
	mov byte [edi+1], 0
	xor ecx, ecx
__loop_negative@toString:
	dec edi
	inc ecx
	xor edx, edx
	idiv ebx
	add edx, 48
	mov byte [edi], dl
	cmp eax, 0
	jnz __loop_negative@toString
	dec edi
	mov byte [edi], 45
	inc ecx
	lea eax, [edi-4]
	mov dword [eax], ecx
	ret
__positive@toString:
	mov ebx, edi
	mov edi, 15
	call malloc
	lea edi, [eax+13]
	mov eax, ebx
	mov ebx, 10
	mov byte [edi+1], 0
	xor ecx, ecx
__loop_positive@toString:
	dec edi
	inc ecx
	xor edx, edx
	idiv ebx
	add edx, 48
	mov byte [edi], dl
	cmp eax, 0
	jnz __loop_positive@toString
	inc ecx
	lea eax, [edi-4]
	mov dword [eax], ecx
	ret
@getInt:
    push rbp
    mov rbp, rsp
    mov esi, int$buf
    mov edi, int$fmt
    xor eax, eax
    call scanf
    mov eax, [rel int$buf]
    leave
    ret
@print:
    lea rsi, [rdi+4]
    mov edx, dword [rdi]
    dec edx
    mov rdi, 0
    mov rax, 1
    syscall

