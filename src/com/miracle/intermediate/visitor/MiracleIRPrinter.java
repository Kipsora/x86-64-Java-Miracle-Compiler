package com.miracle.intermediate.visitor;

import com.miracle.intermediate.MiracleIR;
import com.miracle.intermediate.instruction.MiracleIRCall;
import com.miracle.intermediate.instruction.MiracleIRCompare;
import com.miracle.intermediate.instruction.MiracleIRHeapAllocate;
import com.miracle.intermediate.instruction.MiracleIRMove;
import com.miracle.intermediate.instruction.arithmetic.MiracleIRBinaryArithmetic;
import com.miracle.intermediate.instruction.arithmetic.MiracleIRPrefixArithmetic;
import com.miracle.intermediate.instruction.fork.MiracleIRBranch;
import com.miracle.intermediate.instruction.fork.MiracleIRJump;
import com.miracle.intermediate.instruction.fork.MiracleIRReturn;
import com.miracle.intermediate.structure.MiracleIRBasicBlock;
import com.miracle.intermediate.structure.MiracleIRFunction;

import java.util.HashSet;
import java.util.Set;

public class MiracleIRPrinter implements MiracleIRVisitor {
    private StringBuilder builder;
    private Set<String> printedBlock;

    public String getOutput() {
        return builder.toString();
    }

    @Override
    public void visit(MiracleIR ir) {
        builder = new StringBuilder();
        printedBlock = new HashSet<>();
        builder.append("; Code generated by Kipsora").append('\n').append('\n');
        builder.append("section .bss:").append('\n');
        ir.globalVariable.forEach((key, value) ->
                builder.append(key).append(':').append('\t')
                        .append("resb").append(' ').append(value.size).append('\n')
        );
        builder.append('\n');
        builder.append("section .data:").append('\n');
        ir.globalString.forEach((key, value) ->
                builder.append(value.name).append(':').append('\t')
                        .append("db").append(' ').append(value.value.length() - 1)
                        .append(' ').append(value.value).append(", ").append('0')
                        .append('\n')
        );
        builder.append('\n');
        builder.append("section .text:").append('\n');
        ir.globalFunction.forEach((key, value) -> {
            value.accept(this);
            builder.append('\n');
        });
    }

    @Override
    public void visit(MiracleIRBinaryArithmetic binaryArithmetic) {
        builder.append('\t').append(binaryArithmetic.operator).append(' ')
                .append(binaryArithmetic.target).append(", ")
                .append(binaryArithmetic.source).append('\n');
    }

    @Override
    public void visit(MiracleIRMove move) {
        builder.append('\t').append("mov").append(' ').append(move.target)
                .append(", ").append(move.source).append('\n');
    }

    @Override
    public void visit(MiracleIRFunction function) {
        builder.append("func ").append(function.identifier);
        function.parameters.forEach(element -> builder.append(' ').append(element));
        builder.append(' ').append('{').append('\n');
        builder.append("stack frame: {").append('\n');
        function.buffer.getRegisters().forEach((element, address) ->
                builder.append('\t').append(element).append(' ')
                        .append(element.getNumberSize()).append('\n')
        );

        builder.append("}").append('\n');
        function.getEntryBasicBlock().accept(this);
        builder.append('}').append('\n');
    }

    @Override
    public void visit(MiracleIRBasicBlock block) {
        if (printedBlock.contains(block.name)) return;
        printedBlock.add(block.name);
        builder.append(block.name).append(':').append('\n');
        for (MiracleIRBasicBlock.Node it = block.getHead(); it != block.tail; it = it.getSucc()) {
            it.instruction.accept(this);
        }
        block.getSuccBasicBlock().forEach(element -> element.accept(this));
    }

    @Override
    public void visit(MiracleIRCall call) {
        builder.append('\t').append("call").append(' ').append("ret=")
                .append(call.returnRegister).append(' ')
                .append("self=").append(call.selfRegister)
                .append(' ').append(call.function.identifier);
        call.parameters.forEach(element -> builder.append(' ').append(element));
        builder.append('\n');
    }

    @Override
    public void visit(MiracleIRPrefixArithmetic prefixArithmetic) {
        builder.append('\t').append(prefixArithmetic.operator).append(' ')
                .append(prefixArithmetic.target).append('\n');
    }

    @Override
    public void visit(MiracleIRBranch branch) {
        builder.append('\t').append("jnz").append(' ').append(branch.expression)
                .append(", ").append(branch.branchTrue.name)
                .append(", ").append(branch.branchFalse.name)
                .append('\n');
    }

    @Override
    public void visit(MiracleIRReturn irReturn) {
        builder.append('\t').append("ret").append('\n');
    }

    @Override
    public void visit(MiracleIRJump jump) {
        builder.append('\t').append("jmp").append(' ')
                .append(jump.block.name).append('\n');
    }

    @Override
    public void visit(MiracleIRCompare compare) {
        builder.append('\t').append("cmp").append(' ')
                .append(compare.sourceA).append(", ")
                .append(compare.sourceB).append('\n');
        builder.append('\t').append(compare.operator).append(' ')
                .append(compare.target).append('\n');
    }

    @Override
    public void visit(MiracleIRHeapAllocate allocate) {
        builder.append('\t').append("haloc").append(' ')
                .append(allocate.register).append(", ")
                .append(allocate.number).append(", ")
                .append(allocate.size).append('\n');
    }
}
