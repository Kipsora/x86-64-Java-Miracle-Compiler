; Code generated by Kipsora

section .bss:

section .data:
.str81:	db 8 "x * y: ", 0
.str78:	db 8 "x + y: ", 0
.str38:	db 3 "( ", 0
.str49:	db 3 " )", 0
.str45:	db 3 ", ", 0
.str75:	db 9 "excited!", 0
.str76:	db 11 "vector y: ", 0
.str70:	db 11 "vector x: ", 0
.str84:	db 15 "(1 << 3) * y: ", 0

section .text:
func @vector.add $rhs {
stack frame: {
	$.retval 4
	$this 4
	$rhs 4
	$.t22 4
	$.t23 4
	$.t24 4
	$.t25 4
	$.t26 4
	$.t27 4
	$temp 4
	$.t28 4
	$i 4
	$.t29 4
	$.t30 4
	$.t31 4
	$.t32 4
	$.t33 4
	$.t34 4
}
__@vector.add.entry:
	call ret=$.t22 self=null @vector.getDim
	call ret=$.t23 self=$rhs @vector.getDim
	cmp $.t22, $.t23
	setne $.t24
	call ret=$.t25 self=null @vector.getDim
	cmp $.t25, 0
	sete $.t26
	mov $.t27, $.t24
	or $.t27, $.t26
	jnz $.t27, if_pass_21, if_fail_22
if_pass_21:
	mov $.retval, 0
	ret
if_fail_22:
	jmp if_both_23
if_both_23:
	haloc $.t28, 1, 4
	mov $temp, $.t28
	mov $i, 0
	jmp iter_cond_24
iter_cond_24:
	call ret=$.t29 self=null @vector.getDim
	cmp $i, $.t29
	setl $.t30
	jnz $.t30, iter_body_25, iter_exit_26
iter_body_25:
	mov $.t31, $.t31
	mov $.t32, $.t32
	mov $.t33, $.t33
	mov $.t34, [$.t32+$i*4,4]
	add $.t34, [$.t33+$i*4,4]
	mov [$.t31+$i*4,4], $.t34
	inc $i
	jmp iter_cond_24
iter_exit_26:
	mov $.retval, $temp
	ret
}

func @vector.init $vec {
stack frame: {
	$this 4
	$vec 4
	$.t0 4
	$.t1 4
	$.t2 4
	$new_init_iter_3 4
	$new_init_flag_4 4
	$.t5 4
	$i 4
	$.t6 4
	$.t7 4
	$.t8 4
}
__@vector.init.entry:
	cmp $vec, 0
	sete $.t0
	jnz $.t0, if_pass_0, if_fail_1
if_pass_0:
	ret
if_fail_1:
	jmp if_both_2
if_both_2:
	call ret=$.t2 self=$vec @array.size
	haloc $.t1, $.t2, 4
	xor $new_init_iter_3, $new_init_iter_3
	jmp new_init_cond_3
new_init_cond_3:
	cmp $new_init_iter_3, $.t2
	setl $new_init_flag_4
	jnz $new_init_flag_4, new_init_body_5, new_init_exit_4
new_init_body_5:
	haloc $.t5, 1, 4
	mov [$.t1+$new_init_iter_3*4,4], $.t5
	jmp new_init_cond_3
new_init_exit_4:
	mov [$this+0,4], null
	mov $i, 0
	jmp iter_cond_6
iter_cond_6:
	call ret=$.t6 self=$vec @array.size
	cmp $i, $.t6
	setl $.t7
	jnz $.t7, iter_body_7, iter_exit_8
iter_body_7:
	mov $.t8, $.t8
	mov [$.t8+$i*4,4], [$vec+$i*4,4]
	inc $i
	jmp iter_cond_6
iter_exit_8:
}

func @vector.scalarInPlaceMultiply $c {
stack frame: {
	$.retval 4
	$this 4
	$c 4
	$.t16 4
	$i 4
	$.t17 4
	$.t18 4
	$.t19 4
	$.t20 4
	$.t21 4
}
__@vector.scalarInPlaceMultiply.entry:
	cmp [$this+0,4], 0
	sete $.t16
	jnz $.t16, if_pass_15, if_fail_16
if_pass_15:
	mov $.retval, 0
	ret
if_fail_16:
	jmp if_both_17
if_both_17:
	mov $i, 0
	jmp iter_cond_18
iter_cond_18:
	call ret=$.t17 self=null @vector.getDim
	cmp $i, $.t17
	setl $.t18
	jnz $.t18, iter_body_19, iter_exit_20
iter_body_19:
	mov $.t19, $.t19
	mov $.t20, $.t20
	mov $.t21, $c
	imul $.t21, [$.t20+$i*4,4]
	mov [$.t19+$i*4,4], $.t21
	inc $i
	jmp iter_cond_18
iter_exit_20:
	mov $.retval, $this
	ret
}

func @vector.set $idx $value {
stack frame: {
	$.retval 1
	$this 4
	$idx 4
	$value 4
	$.t35 4
	$.t36 4
	$.t37 4
}
__@vector.set.entry:
	call ret=$.t35 self=null @vector.getDim
	cmp $.t35, $idx
	setl $.t36
	jnz $.t36, if_pass_27, if_fail_28
if_pass_27:
	mov $.retval, 0
	ret
if_fail_28:
	jmp if_both_29
if_both_29:
	mov $.t37, $.t37
	mov [$.t37+$idx*4,4], $value
	mov $.retval, 1
	ret
}

func @vector.dot $rhs {
stack frame: {
	$.retval 4
	$this 4
	$rhs 4
	$i 4
	$result 4
	$.t11 4
	$.t12 4
	$.t13 4
	$.t14 4
	$.t15 4
}
__@vector.dot.entry:
	mov $i, 0
	mov $result, 0
	jmp iter_cond_12
iter_cond_12:
	call ret=$.t11 self=null @vector.getDim
	cmp $i, $.t11
	setl $.t12
	jnz $.t12, iter_body_13, iter_exit_14
iter_body_13:
	mov $.t13, $.t13
	mov $.t14, $.t14
	mov $.t15, [$.t13+$i*4,4]
	imul $.t15, [$.t14+$i*4,4]
	mov $result, $.t15
	inc $i
	jmp iter_cond_12
iter_exit_14:
	mov $.retval, $result
	ret
}

func @vector.getDim {
stack frame: {
	$.retval 4
	$this 4
	$.t9 4
	$.t10 4
}
__@vector.getDim.entry:
	cmp [$this+0,4], 0
	sete $.t9
	jnz $.t9, if_pass_9, if_fail_10
if_pass_9:
	mov $.retval, 0
	ret
if_fail_10:
	jmp if_both_11
if_both_11:
	call ret=$.t10 self=[$this+0,4] @array.size
	mov $.retval, $.t10
	ret
}

func @vector.toString {
stack frame: {
	$.retval 4
	$this 4
	$temp 4
	$.t39 4
	$.t40 4
	$.t41 4
	$.t42 4
	$i 4
	$.t43 4
	$.t44 4
	$.t46 4
	$.t47 4
	$.t48 4
	$.t50 4
}
__@vector.toString.entry:
	mov $temp, $.str38
	call ret=$.t39 self=null @vector.getDim
	cmp $.t39, 0
	setg $.t40
	jnz $.t40, if_pass_30, if_fail_31
if_pass_30:
	call ret=$.t41 self=null @vector.toString
	call ret=$.t42 self=null @strcat $temp $.t41
	mov $temp, $.t42
	jmp if_both_32
if_both_32:
	mov $i, 1
	jmp iter_cond_33
iter_cond_33:
	call ret=$.t43 self=null @vector.getDim
	cmp $i, $.t43
	setl $.t44
	jnz $.t44, iter_body_34, iter_exit_35
iter_body_34:
	call ret=$.t46 self=null @strcat $temp $.str45
	call ret=$.t47 self=null @vector.toString
	call ret=$.t48 self=null @strcat $.t46 $.t47
	mov $temp, $.t48
	inc $i
	jmp iter_cond_33
iter_exit_35:
	call ret=$.t50 self=null @strcat $temp $.str49
	mov $temp, $.t50
	mov $.retval, $temp
	ret
if_fail_31:
	jmp if_both_32
}

func main {
stack frame: {
	$.retval 4
	$x 4
	$.t63 4
	$a 4
	$.t64 4
	$new_init_iter_65 4
	$new_init_flag_66 4
	$.t67 4
	$i 4
	$.t68 4
	$.t69 4
	$.t71 4
	$y 4
	$.t72 4
	$.t73 1
	$.t74 1
	$.t77 4
	$.t79 4
	$.t80 4
	$.t82 4
	$.t83 4
	$.t85 4
	$.t86 4
	$.t87 4
}
__main.entry:
	haloc $.t63, 1, 4
	mov $x, $.t63
	haloc $.t64, 10, 4
	xor $new_init_iter_65, $new_init_iter_65
	jmp new_init_cond_48
new_init_cond_48:
	cmp $new_init_iter_65, 10
	setl $new_init_flag_66
	jnz $new_init_flag_66, new_init_body_50, new_init_exit_49
new_init_body_50:
	haloc $.t67, 1, 4
	mov [$.t64+$new_init_iter_65*4,4], $.t67
	jmp new_init_cond_48
new_init_exit_49:
	mov $a, null
	mov $i, 0
	jmp iter_cond_51
iter_cond_51:
	cmp $i, 10
	setl $.t68
	jnz $.t68, iter_body_52, iter_exit_53
iter_body_52:
	mov $.t69, 9
	sub $.t69, $i
	mov [$a+$i*4,4], $.t69
	inc $i
	jmp iter_cond_51
iter_exit_53:
	call ret=null self=$x @vector.init $a
	call ret=null self=null @print $.str70
	call ret=$.t71 self=$x @vector.toString
	call ret=null self=null @println $.t71
	haloc $.t72, 1, 4
	mov $y, $.t72
	call ret=$.t73 self=$y @vector.copy $x
	call ret=$.t74 self=$y @vector.set 3 817
	jnz $.t74, if_pass_54, if_fail_55
if_pass_54:
	call ret=null self=null @println $.str75
	jmp if_both_56
if_both_56:
	call ret=null self=null @print $.str76
	call ret=$.t77 self=$y @vector.toString
	call ret=null self=null @println $.t77
	call ret=null self=null @print $.str78
	call ret=$.t79 self=$x @vector.add $y
	call ret=$.t80 self=$.t79 @vector.toString
	call ret=null self=null @println $.t80
	call ret=null self=null @print $.str81
	call ret=$.t82 self=$x @vector.dot $y
	call ret=$.t83 self=null @toString $.t82
	call ret=null self=null @println $.t83
	call ret=null self=null @print $.str84
	mov $.t85, 1
	shl $.t85, 3
	call ret=$.t86 self=$x @vector.scalarInPlaceMultiply $.t85
	call ret=$.t87 self=$.t86 @vector.toString
	call ret=null self=null @println $.t87
if_fail_55:
	jmp if_both_56
}

func @vector.copy $rhs {
stack frame: {
	$.retval 1
	$this 4
	$rhs 4
	$.t51 4
	$.t52 4
	$.t53 4
	$.t54 4
	$.t55 4
	$new_init_iter_56 4
	$new_init_flag_57 4
	$.t58 4
	$i 4
	$.t59 4
	$.t60 4
	$.t61 4
	$.t62 4
}
__@vector.copy.entry:
	cmp $rhs, 0
	sete $.t51
	jnz $.t51, if_pass_36, if_fail_37
if_pass_36:
	mov $.retval, 0
	ret
if_fail_37:
	jmp if_both_38
if_both_38:
	call ret=$.t52 self=$rhs @vector.getDim
	cmp $.t52, 0
	sete $.t53
	jnz $.t53, if_pass_39, if_fail_40
if_pass_39:
	mov [$this+0,4], 0
	jmp if_both_41
if_both_41:
	mov $.retval, 1
	ret
if_fail_40:
	call ret=$.t55 self=$rhs @vector.getDim
	haloc $.t54, $.t55, 4
	xor $new_init_iter_56, $new_init_iter_56
	jmp new_init_cond_42
new_init_cond_42:
	cmp $new_init_iter_56, $.t55
	setl $new_init_flag_57
	jnz $new_init_flag_57, new_init_body_44, new_init_exit_43
new_init_body_44:
	haloc $.t58, 1, 4
	mov [$.t54+$new_init_iter_56*4,4], $.t58
	jmp new_init_cond_42
new_init_exit_43:
	mov [$this+0,4], null
	mov $i, 0
	jmp iter_cond_45
iter_cond_45:
	call ret=$.t59 self=null @vector.getDim
	cmp $i, $.t59
	setl $.t60
	jnz $.t60, iter_body_46, iter_exit_47
iter_body_46:
	mov $.t61, $.t61
	mov $.t62, $.t62
	mov [$.t61+$i*4,4], [$.t62+$i*4,4]
	inc $i
	jmp iter_cond_45
iter_exit_47:
	jmp if_both_41
}


